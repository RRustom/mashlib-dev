{"version":3,"sources":["../../../src/widgets/forms/fieldFunction.ts"],"names":["store","solidLogicSingleton","field","mostSpecificClassURI","x","kb","ft","findTypeURIs","bot","bottomTypeURIs","bots","b","push","fieldFunction","dom","fieldInQuestion","uri","fun","dom2","container","box","appendChild"],"mappings":";;;;;;;;;AACA;;AACA;;AACA;;AAEA,IAAMA,KAAK,GAAGC,2BAAoBD,KAAlC;AAYO,IAAME,KAA4C,GAAG,EAArD,C,CAAwD;;AAE/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;AACO,SAASC,oBAAT,CAA+BC,CAA/B,EAAgD;AACrD,MAAMC,EAAE,GAAGL,KAAX;AACA,MAAMM,EAAE,GAAGD,EAAE,CAACE,YAAH,CAAgBH,CAAhB,CAAX;AACA,MAAMI,GAAG,GAAGH,EAAE,CAACI,cAAH,CAAkBH,EAAlB,CAAZ,CAHqD,CAGnB;;AAClC,MAAMI,IAAW,GAAG,EAApB;;AACA,OAAK,IAAMC,CAAX,IAAgBH,GAAhB;AAAqBE,IAAAA,IAAI,CAACE,IAAL,CAAUD,CAAV;AAArB,GALqD,CAMrD;;;AACA,SAAOD,IAAI,CAAC,CAAD,CAAX;AACD;AAED;AACA;AACA;AACA;AACA;;;AACO,SAASG,aAAT,CAAwBC,GAAxB;AAAiC;AAAcC,eAA/C,EAAqF;AAC1F,MAAMC,GAAG,GAAGb,oBAAoB,CAACY,eAAD,CAAhC,CAD0F,CACxC;AAClD;;AACA,MAAME,GAAG,GAAGf,KAAK,CAACc,GAAD,CAAjB;AACA,kBACE,yCAAyCD,eAAzC,GAA2D,WAA3D,GAAyEC,GAD3E;;AAGA,MAAI,CAACC,GAAL,EAAU;AACR,WAAO,UAAUC,IAAV,EAA8BC,SAA9B,EAAoE;AACzE,UAAMC,GAAG,GAAG,8BACVF,IADU,EAEV,0BAA0BH,eAA1B,GAA4C,WAA5C,GAA0DC,GAFhD,CAAZ;AAIA,UAAIG,SAAJ,EAAeA,SAAS,CAACE,WAAV,CAAsBD,GAAtB;AAEf,aAAOA,GAAP;AACD,KARD;AASD;;AACD,SAAOH,GAAP;AACD","sourcesContent":["import { Node } from 'rdflib'\nimport { solidLogicSingleton } from '../../logic'\nimport { debug } from '../../log'\nimport { errorMessageBlock } from '../error'\n\nconst store = solidLogicSingleton.store\n\nexport type FieldFunction = (\n  dom: HTMLDocument, // the DOM\n  container: HTMLElement | undefined, // if defined, the box will be appended to it\n  already: { }, // used to avoid looping in nested forms\n  subject: Node, // the thing for which data will be loaded into the form element\n  form: Node, // the RDF declaration for what the form should have\n  doc: Node, // the online RDF document for data binding (form input values will be read/saved automatically)\n  callbackFunction: (ok: boolean, errorMessage: string) => void // this will be called when data changes (TODO: check this with unit tests)\n) => HTMLElement\n\nexport const field: { [classUri: string]: FieldFunction } = {} // Form field functions by URI of field type.\n\n/**\n * Which class of field is this? Relies on http://www.w3.org/2000/01/rdf-schema#subClassOf and\n * https://linkeddata.github.io/rdflib.js/doc/classes/formula.html#bottomtypeuris\n * to find the most specific RDF type if there are multiple.\n *\n * @param x a form field, e.g. `namedNode('https://timbl.com/timbl/Public/Test/Forms/individualForm.ttl#fullNameField')`\n * @returns the URI of the most specific known class, e.g. `http://www.w3.org/ns/ui#SingleLineTextField`\n */\nexport function mostSpecificClassURI (x: Node): string {\n  const kb = store\n  const ft = kb.findTypeURIs(x as any)\n  const bot = kb.bottomTypeURIs(ft) // most specific\n  const bots: any[] = []\n  for (const b in bot) bots.push(b)\n  // if (bots.length > 1) throw \"Didn't expect \"+x+\" to have multiple bottom types: \"+bots\n  return bots[0]\n}\n\n/**\n * Returns a function that creates a form widget\n * @param dom unused\n * @param fieldInQuestion the field for which to create a form, e.g. namedNode('https://timbl.com/timbl/Public/Test/Forms/individualForm.ttl#fullNameField')\n */\nexport function fieldFunction (dom: any /* unused */, fieldInQuestion: Node): FieldFunction {\n  const uri = mostSpecificClassURI(fieldInQuestion) // What type\n  // const uri = field.uri\n  const fun = field[uri]\n  debug(\n    'paneUtils: Going to implement field ' + fieldInQuestion + ' of type ' + uri\n  )\n  if (!fun) {\n    return function (dom2: HTMLDocument, container?: HTMLElement): HTMLElement {\n      const box = errorMessageBlock(\n        dom2,\n        'No handler for field ' + fieldInQuestion + ' of type ' + uri\n      )\n      if (container) container.appendChild(box)\n\n      return box\n    }\n  }\n  return fun\n}\n"],"file":"fieldFunction.js"}